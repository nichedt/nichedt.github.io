

<!DOCTYPE html>
<!-- snake.html by Nicholas Tan -->
<!-- snake game -->

<html>
	<canvas id="ctx" width="512" height="512" style="border:1px solid #000000;"></canvas>
	
<script>
		
	ctx = document.getElementById("ctx").getContext("2d");
	ctx.globalAlpha = 0.5;
	
	var WIDTH = 512;
	var HEIGHT = 512;
	
	var length0 = 8;
	var x0 = WIDTH/16;
	var y0 = WIDTH/16;
	
	var snake = {
		color:'pink',
		head:{
			x:length0*x0,
			y:y0,
			dir:39, //right
		},
		tail:{
			x:x0,
			y:y0,
			dir:39, //right
		},
		blockSize:WIDTH/16,
		borderSize:WIDTH/16/16,
		turnq:[],
		length:length0,
	};
				 
	 var food = {
		 x:snake.head.y,
		 y:snake.head.x,
		 taken:[ 	[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
					[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],	],
	 };
	
	ctx.fillStyle = 'red'; //initial "burrow hole"
	ctx.fillRect( 	snake.head.x+snake.borderSize       ,
				 snake.head.y+snake.borderSize       ,
				 snake.blockSize-snake.borderSize    ,
				 snake.blockSize-snake.borderSize    );
				 ctx.fillStyle = snake.color;
	food.taken[snake.head.y/snake.blockSize][snake.head.x/snake.blockSize] = 1; //set bit
	
	spawnFood();
	
	var frame = setInterval(update,140);
	
//function definitions
function update(){
	
	if(snake.turnq.length > 0){
		snake.head.dir = snake.turnq[snake.turnq.length-1].dir;
	}
	
	blockPosUpdate(snake.head);
	 if(isDead()){
	   clearInterval(frame);
	   console.log("game over!");
	   return;
	 }
	food.taken[snake.head.y/snake.blockSize][snake.head.x/snake.blockSize] = 1; //set bit
	
	if(snake.head.x != food.x || snake.head.y != food.y){
		ctx.clearRect(snake.tail.x,snake.tail.y,snake.blockSize,snake.blockSize);
		food.taken[snake.tail.y/snake.blockSize][snake.tail.x/snake.blockSize] = 0; //clear bits
		blockPosUpdate(snake.tail);
	}else{
		snake.length++;
		spawnFood();
	}
	
	ctx.fillRect(   		snake.head.x+snake.borderSize       ,
				 snake.head.y+snake.borderSize       ,
				 snake.blockSize-snake.borderSize    ,
				 snake.blockSize-snake.borderSize    );
	
	 if(snake.turnq.length > 0){
		 if( snake.turnq[0].x == snake.tail.x &&
			snake.turnq[0].y == snake.tail.y ){
			 snake.tail.dir = snake.turnq.shift().dir; // O(n) complexity
		 }
	 }
}
function spawnFood(){
	var pos = Math.floor(Math.random() * (16*16-snake.length));
	var counter = -1;
	for(var i=0; i<16; i++){
		for(var j=0; j<16; j++){
			if(	food.taken[i][j] == 0 ){
				counter++;
				if( counter == pos ){
					console.log(food.x);
					food.y = i*WIDTH/16;
					food.x = j*HEIGHT/16;
				}
			}
		}
	}
	ctx.beginPath();
	ctx.arc(	food.x+(snake.borderSize+snake.blockSize)/2		,
				food.y+(snake.borderSize+snake.blockSize)/2		,
				(snake.blockSize-4*snake.borderSize)/2			,
				0												,
				2*Math.PI										);
	ctx.stroke();
}
function isDead(){
	
	//wall collisions
	if( snake.head.x+snake.blockSize > WIDTH    ||
	   snake.head.x+snake.blockSize <= 0       ||
	   snake.head.y+snake.blockSize > HEIGHT   ||
	   snake.head.y+snake.blockSize <= 0       ){
		return true;
	}
	   
	   return bodyCollide(snake.head);
}
function bodyCollide(block){
	if(snake.turnq.length > 0){
		switch(snake.tail.dir){
			case 37: //left
			if(headIntersect(block, "y", snake.tail, snake.turnq[0])){
				return true;
			}
			break;
			case 38: //up
			if(headIntersect(block, "x", snake.tail, snake.turnq[0])){
				return true;
			}
			break;
			case 39: //right
			if(headIntersect(block, "y", snake.turnq[0], snake.tail)){
				return true;
			}
			break;
			case 40: //down
			if(headIntersect(block, "x", snake.turnq[0], snake.tail)){
				return true;
			}
			break;
		}
	}
	for(var i = 1; i < snake.turnq.length; i++){
		switch(snake.turnq[i-1].dir){
			case 37: //left
			if(headIntersect(block, "y", snake.turnq[i-1], snake.turnq[i])){
				return true;
			}
			break;
			case 38: //up
			if(headIntersect(block, "x", snake.turnq[i-1], snake.turnq[i])){
				return true;
			}
			break;
			case 39: //right
			if(headIntersect(block, "y", snake.turnq[i], snake.turnq[i-1])){
				return true;
			}
			break;
			case 40: //down
			if(headIntersect(block, "x", snake.turnq[i], snake.turnq[i-1])){
				return true;
			}
			break;
		}
	}
	
	return false;
}
function headIntersect(block, cmnAx, startBlock, endBlock){
	var offAx = (cmnAx == "y")?"x":"y";
	if(block[cmnAx] == startBlock[cmnAx]){
		if(	startBlock[offAx] >= block[offAx]	&&
		block[offAx] >= endBlock[offAx]		){
			return true;
		}
	}
	return false;
}
function blockPosUpdate(block){
	switch(block.dir){
		case 37: //left
		block.x -= snake.blockSize;
		break;
		case 38: //up
		block.y -= snake.blockSize;
		break;
		case 39: //right
		block.x += snake.blockSize;
		break;
		case 40: //down
		block.y += snake.blockSize;
		break;
	}
}
document.onkeydown = function(e) {
	switch (e.keyCode) {
		case 37: //left
		case 38: //up
		case 39: //right
		case 40: //down
			if(	(e.keyCode % 2) != (snake.head.dir % 2) ){ //change direction
				snake.turnq.push({	x:snake.head.x,
									y:snake.head.y,
									dir:e.keyCode,	});
			}
			break;
	}
};
	
	
</script>
	
</html>